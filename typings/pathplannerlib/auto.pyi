"""
This type stub file was generated by pyright.
"""

from wpilib.event import EventLoop
from .path import PathConstraints, PathPlannerPath
from typing import Callable, List
from wpimath.geometry import Pose2d, Translation2d
from wpimath.kinematics import ChassisSpeeds
from .util import DriveFeedforwards
from .controller import PathFollowingController
from wpilib import SendableChooser, Timer
from commands2.command import Command
from commands2.subsystem import Subsystem
from commands2.button import Trigger
from .config import RobotConfig

class NamedCommands:
    _namedCommands: dict = ...
    @staticmethod
    def registerCommand(name: str, command: Command) -> None:
        """
        Registers a command with the given name

        :param name: the name of the command
        :param command: the command to register
        """
        ...

    @staticmethod
    def hasCommand(name: str) -> bool:
        """
        Returns whether a command with the given name has been registered.

        :param name: the name of the command to check
        :return: true if a command with the given name has been registered, false otherwise
        """
        ...

    @staticmethod
    def getCommand(name: str) -> Command:
        """
        Returns the command with the given name.

        :param name: the name of the command to get
        :return: the command with the given name, wrapped in a functional command, or a none command if it has not been registered
        """
        ...

class CommandUtil:
    @staticmethod
    def wrappedEventCommand(event_command: Command) -> Command:
        """
        Wraps a command with a functional command that calls the command's initialize, execute, end,
        and isFinished methods. This allows a command in the event map to be reused multiple times in
        different command groups

        :param event_command: the command to wrap
        :return: a functional command that wraps the given command
        """
        ...

    @staticmethod
    def commandFromJson(
        command_json: dict, load_choreo_paths: bool, mirror: bool
    ) -> Command:
        """
        Builds a command from the given json object

        :param command_json: the json dict to build the command from
        :param load_choreo_paths: Load path commands using choreo trajectories
        :param mirror: Should the paths be mirrored
        :return: a command built from the json dict
        """
        ...

class PathPlannerAuto(Command):
    _autoCommand: Command
    _startingPose: Pose2d
    _autoLoop: EventLoop
    _timer: Timer
    _isRunning: bool = ...
    _instances: int = ...
    def __init__(self, auto_name: str, mirror: bool = ...) -> None:
        """
        Constructs a new PathPlannerAuto command.

        :param auto_name: the name of the autonomous routine to load and run
        :param mirror: Mirror all paths to the other side of the current alliance. For example, if a
            path is on the right of the blue alliance side of the field, it will be mirrored to the
            left of the blue alliance side of the field.
        """
        ...

    @staticmethod
    def getPathGroupFromAutoFile(auto_name: str) -> List[PathPlannerPath]:
        """
        Get a list of every path in the given auto (depth first)

        :param auto_name: Name of the auto to get the path group from
        :return: List of paths in the auto
        """
        ...

    def initialize(self) -> None: ...
    def execute(self) -> None: ...
    def isFinished(self) -> bool: ...
    def end(self, interrupted: bool) -> None: ...
    def condition(self, condition: Callable[[], bool]) -> Trigger:
        """
        Create a trigger with a custom condition. This will be polled by this auto's event loop so that
        its condition is only polled when this auto is running.

        :param condition: The condition represented by this trigger
        :return: Custom condition trigger
        """
        ...

    def isRunning(self) -> Trigger:
        """
        Create a trigger that is high when this auto is running, and low when it is not running

        :return: isRunning trigger
        """
        ...

    def timeElapsed(self, time: float) -> Trigger:
        """
        Trigger that is high when the given time has elapsed

        :param time: The amount of time this auto should run before the trigger is activated
        :return: timeElapsed trigger
        """
        ...

    def timeRange(self, startTime: float, endTime: float) -> Trigger:
        """
        Trigger that is high when within a range of time since the start of this auto

        :param startTime: The starting time of the range
        :param endTime: The ending time of the range
        :return: timeRange trigger
        """
        ...

    def event(self, eventName: str) -> Trigger:
        """
        Create an EventTrigger that will be polled by this auto instead of globally across all path
        following commands

        :param eventName: The event name that controls this trigger
        :return: EventTrigger for this auto
        """
        ...

    def pointTowardsZone(self, zoneName: str) -> Trigger:
        """
        Create a PointTowardsZoneTrigger that will be polled by this auto instead of globally across
        all path following commands

        :param zoneName: The point towards zone name that controls this trigger
        :return: PointTowardsZoneTrigger for this auto
        """
        ...

    def activePath(self, pathName: str) -> Trigger:
        """
        Create a trigger that is high when a certain path is being followed

        :param pathName: The name of the path to check for
        :return: activePath trigger
        """
        ...

    def nearFieldPosition(
        self, fieldPosition: Translation2d, toleranceMeters: float
    ) -> Trigger:
        """
        Create a trigger that is high when near a given field position. This field position is not
        automatically flipped

        :param fieldPosition: The target field position
        :param toleranceMeters: The position tolerance, in meters. The trigger will be high when within this distance \
            from the target position
        :return: nearFieldPosition trigger
        """
        ...

    def nearFieldPositionAutoFlipped(
        self, blueFieldPosition: Translation2d, toleranceMeters: float
    ) -> Trigger:
        """
        Create a trigger that is high when near a given field position. This field position will be
        automatically flipped

        :param blueFieldPosition: The target field position if on the blue alliance
        :param toleranceMeters: The position tolerance, in meters. The trigger will be high when within
            this distance from the target position
        :return: nearFieldPositionAutoFlipped trigger
        """
        ...

    def inFieldArea(
        self, boundingBoxMin: Translation2d, boundingBoxMax: Translation2d
    ) -> Trigger:
        """
        Create a trigger that will be high when the robot is within a given area on the field. These
        positions will not be automatically flipped

        :param boundingBoxMin: The minimum position of the bounding box for the target field area. The X
            and Y coordinates of this position should be less than the max position.
        :param boundingBoxMax: The maximum position of the bounding box for the target field area. The X
            and Y coordinates of this position should be greater than the min position.
        :return: inFieldArea trigger
        """
        ...

    def inFieldAreaAutoFlipped(
        self, blueBoundingBoxMin: Translation2d, blueBoundingBoxMax: Translation2d
    ) -> Trigger:
        """
        Create a trigger that will be high when the robot is within a given area on the field. These
        positions will be automatically flipped

        :param blueBoundingBoxMin: The minimum position of the bounding box for the target field area if
             on the blue alliance. The X and Y coordinates of this position should be less than the max
             position.
        :param blueBoundingBoxMax: The maximum position of the bounding box for the target field area if
            on the blue alliance. The X & Y coordinates of this position should be greater than the min
            position.
        :return: inFieldAreaAutoFlipped trigger
        """
        ...

class AutoBuilder:
    _configured: bool = ...
    _pathFollowingCommandBuilder: Callable[[PathPlannerPath], Command] = ...
    _getPose: Callable[[], Pose2d] = ...
    _resetPose: Callable[[Pose2d], None] = ...
    _shouldFlipPath: Callable[[], bool] = ...
    _isHolonomic: bool = ...
    _pathfindingConfigured: bool = ...
    _pathfindToPoseCommandBuilder: Callable[
        [Pose2d, PathConstraints, float], Command
    ] = ...
    _pathfindThenFollowPathCommandBuilder: Callable[
        [PathPlannerPath, PathConstraints], Command
    ] = ...
    @staticmethod
    def configure(
        pose_supplier: Callable[[], Pose2d],
        reset_pose: Callable[[Pose2d], None],
        robot_relative_speeds_supplier: Callable[[], ChassisSpeeds],
        output: Callable[[ChassisSpeeds, DriveFeedforwards], None],
        controller: PathFollowingController,
        robot_config: RobotConfig,
        should_flip_path: Callable[[], bool],
        drive_subsystem: Subsystem,
    ) -> None:
        """
        Configures the AutoBuilder for using PathPlanner's built-in commands.

        :param pose_supplier: a supplier for the robot's current pose
        :param reset_pose: a consumer for resetting the robot's pose
        :param robot_relative_speeds_supplier: a supplier for the robot's current robot relative chassis speeds
        :param output: Output function that accepts robot-relative ChassisSpeeds and feedforwards for
            each drive motor. If using swerve, these feedforwards will be in FL, FR, BL, BR order. If
            using a differential drive, they will be in L, R order.
            <p>NOTE: These feedforwards are assuming unoptimized module states. When you optimize your
            module states, you will need to reverse the feedforwards for modules that have been flipped
        :param controller Path following controller that will be used to follow paths
        :param robot_config The robot configuration
        :param should_flip_path: Supplier that determines if paths should be flipped to the other side of the field. This will maintain a global blue alliance origin.
        :param drive_subsystem: the subsystem for the robot's drive
        """
        ...

    @staticmethod
    def configureCustom(
        path_following_command_builder: Callable[[PathPlannerPath], Command],
        reset_pose: Callable[[Pose2d], None],
        isHolonomic: bool,
        should_flip_pose: Callable[[], bool] = ...,
    ) -> None:
        """
        Configures the AutoBuilder with custom path following command builder. Building pathfinding commands is not supported if using a custom command builder.

        :param path_following_command_builder: a function that builds a command to follow a given path
        :param reset_pose: a consumer for resetting the robot's pose
        :param isHolonomic Does the robot have a holonomic drivetrain
        :param should_flip_pose: Supplier that determines if the starting pose should be flipped to the other side of the field. This will maintain a global blue alliance origin. NOTE: paths will not be flipped when configured with a custom path following command. Flipping the paths must be handled in your command.
        """
        ...

    @staticmethod
    def isConfigured() -> bool:
        """
        Returns whether the AutoBuilder has been configured.

        :return: true if the AutoBuilder has been configured, false otherwise
        """
        ...

    @staticmethod
    def isPathfindingConfigured() -> bool:
        """
        Returns whether the AutoBuilder has been configured for pathfinding.

        :return: true if the AutoBuilder has been configured for pathfinding, false otherwise
        """
        ...

    @staticmethod
    def isHolonomic() -> bool:
        """
        Get if AutoBuilder was configured for a holonomic drive train

        :return: True if holonomic
        """
        ...

    @staticmethod
    def getCurrentPose() -> Pose2d:
        """
        Get the current robot pose

        :return: Current robot pose
        """
        ...

    @staticmethod
    def shouldFlip() -> bool:
        """
        Get if a path or field position should currently be flipped

        :return: True if path/positions should be flipped
        """
        ...

    @staticmethod
    def followPath(path: PathPlannerPath) -> Command:
        """
        Builds a command to follow a path with event markers.

        :param path: the path to follow
        :return: a path following command with events for the given path
        """
        ...

    @staticmethod
    def pathfindToPose(
        pose: Pose2d, constraints: PathConstraints, goal_end_vel: float = ...
    ) -> Command:
        """
        Build a command to pathfind to a given pose. If not using a holonomic drivetrain, the pose rotation and
        rotation delay distance will have no effect.

        :param pose: The pose to pathfind to
        :param constraints: The constraints to use while pathfinding
        :param goal_end_vel: The goal end velocity of the robot when reaching the target pose
        :return: A command to pathfind to a given pose
        """
        ...

    @staticmethod
    def pathfindToPoseFlipped(
        pose: Pose2d, constraints: PathConstraints, goal_end_vel: float = ...
    ) -> Command:
        """
        Build a command to pathfind to a given pose that will be flipped based on the value of the path flipping
        supplier when this command is run. If not using a holonomic drivetrain, the pose rotation and rotation delay
        distance will have no effect.

        :param pose: The pose to pathfind to. This will be flipped if the path flipping supplier returns true
        :param constraints: The constraints to use while pathfinding
        :param goal_end_vel: The goal end velocity of the robot when reaching the target pose
        :return: A command to pathfind to a given pose
        """
        ...

    @staticmethod
    def pathfindThenFollowPath(
        goal_path: PathPlannerPath, pathfinding_constraints: PathConstraints
    ) -> Command:
        """
        Build a command to pathfind to a given path, then follow that path. If not using a holonomic drivetrain, the pose rotation delay distance will have no effect.

        :param goal_path: The path to pathfind to, then follow
        :param pathfinding_constraints: The constraints to use while pathfinding
        :return: A command to pathfind to a given path, then follow the path
        """
        ...

    @staticmethod
    def resetOdom(bluePose: Pose2d) -> Command:
        """
        Create a command to reset the robot's odometry to a given blue alliance pose

        :param bluePose: The pose to reset to, relative to blue alliance origin
        :return: Command to reset the robot's odometry
        """
        ...

    @staticmethod
    def buildAuto(auto_name: str) -> Command:
        """
        Builds an auto command for the given auto name.

        :param auto_name: the name of the auto to build
        :return: an auto command for the given auto name
        """
        ...

    @staticmethod
    def buildAutoChooser(default_auto_name: str = ...) -> SendableChooser:
        """
        Create and populate a sendable chooser with all PathPlannerAutos in the project and the default auto name selected.

        :param default_auto_name: the name of the default auto to be selected in the chooser
        :return: a sendable chooser object populated with all of PathPlannerAutos in the project
        """
        ...

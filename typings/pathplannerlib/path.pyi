"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import Final, List, Union
from wpimath.geometry import Pose2d, Rotation2d, Translation2d
from wpimath.kinematics import ChassisSpeeds
from commands2 import Command
from .trajectory import PathPlannerTrajectory
from .config import RobotConfig

targetIncrement: Final[float] = ...
targetSpacing: Final[float] = ...
autoControlDistanceFactor: Final[float] = ...

@dataclass(frozen=True)
class PathConstraints:
    """
    Kinematic path following constraints

    Args:
        maxVelocityMps (float): Max linear velocity (M/S)
        maxAccelerationMpsSq (float): Max linear acceleration (M/S^2)
        maxAngularVelocityRps (float): Max angular velocity (Rad/S)
        maxAngularAccelerationRpsSq (float): Max angular acceleration (Rad/S^2)
        nominalVoltage (float): Nominal battery voltage (Volts)
        unlimited (bool): Should the constraints be unlimited
    """

    maxVelocityMps: float
    maxAccelerationMpsSq: float
    maxAngularVelocityRps: float
    maxAngularAccelerationRpsSq: float
    nominalVoltage: float = ...
    unlimited: bool = ...
    @staticmethod
    def fromJson(json_dict: dict) -> PathConstraints: ...
    @staticmethod
    def unlimitedConstraints(nominalVoltage: float) -> PathConstraints: ...
    def __eq__(self, other) -> bool: ...

@dataclass(frozen=True)
class GoalEndState:
    """
    Describes the goal end state of the robot when finishing a path

    Args:
        velocity (float): The goal end velocity (M/S)
        rotation (Rotation2d): The goal rotation
    """

    velocity: float
    rotation: Rotation2d
    @staticmethod
    def fromJson(json_dict: dict) -> GoalEndState: ...
    def __eq__(self, other) -> bool: ...

@dataclass(frozen=True)
class IdealStartingState:
    """
    Describes the ideal starting state of the robot when starting a path

    Args:
        velocity (float): The ideal starting velocity (M/S)
        rotation (Rotation2d): The ideal starting rotation
    """

    velocity: float
    rotation: Rotation2d
    @staticmethod
    def fromJson(json_dict: dict) -> IdealStartingState: ...
    def __eq__(self, other) -> bool: ...

@dataclass(frozen=True)
class ConstraintsZone:
    """
    A zone on a path with different kinematic constraints

    Args:
        minWaypointPos (float): Starting position of the zone
        maxWaypointPos (float): End position of the zone
        constraints (PathConstraints): PathConstraints to apply within the zone
    """

    minWaypointPos: float
    maxWaypointPos: float
    constraints: PathConstraints
    @staticmethod
    def fromJson(json_dict: dict) -> ConstraintsZone: ...
    def __eq__(self, other) -> bool: ...

@dataclass(frozen=True)
class RotationTarget:
    """
    A target holonomic rotation at a position along a path

    Args:
        waypointRelativePosition (float): Waypoint relative position of this target
        target (Rotation2d): Target rotation
    """

    waypointRelativePosition: float
    target: Rotation2d
    @staticmethod
    def fromJson(json_dict: dict) -> RotationTarget: ...
    def __eq__(self, other) -> bool: ...

@dataclass(frozen=True)
class PointTowardsZone:
    """
    A zone on a path that will force the robot to point towards a position on the field

    Args:
        name (str): The name of this zone. Used for point towards zone triggers
        targetPosition  (Translation2d): The target field position in meters
        minWaypointRelativePos (float): Starting position of the zone
        maxWaypointRelativePos (float): End position of the zone
        rotationOffset (Rotation2d): A rotation offset to add on top of the angle to the target position. For
            example, if you want the robot to point away from the target position, use a rotation offset of 180 degrees
    """

    name: str
    targetPosition: Translation2d
    minWaypointRelativePos: float
    maxWaypointRelativePos: float
    rotationOffset: Rotation2d = ...
    @staticmethod
    def fromJson(json_dict: dict) -> PointTowardsZone: ...
    def flip(self) -> PointTowardsZone:
        """
        Flip this point towards zone to the other side of the field, maintaining a blue alliance origin

        :return: The flipped zone
        """
        ...

@dataclass(frozen=True)
class EventMarker:
    """
    Position along the path that will trigger a command when reached

    Args:
        triggerName (str): The name of the trigger this event marker will control
        waypointRelativePos (float): The waypoint relative position of the marker
        endWaypointRelativePos (float): The end waypoint relative position of the event's zone.
            A value of -1.0 indicates that this event is not zoned.
        command (Command): The command that should be triggered at this marker. Can be None
    """

    triggerName: str
    waypointRelativePos: float
    endWaypointRelativePos: float = ...
    command: Union[Command, None] = ...
    @staticmethod
    def fromJson(json_dict: dict) -> EventMarker: ...
    def __eq__(self, other) -> bool: ...

@dataclass
class PathPoint:
    """
    A point along a pathplanner path

    Args:
        position (Translation2d): Position of the point
        rotationTarget (RotationTarget): Rotation target at this point
        constraints (PathConstraints): The constraints at this point
    """

    position: Translation2d
    rotationTarget: Union[RotationTarget, None] = ...
    constraints: Union[PathConstraints, None] = ...
    distanceAlongPath: float = ...
    maxV: float = ...
    waypointRelativePos: float = ...
    def flip(self) -> PathPoint: ...
    def __eq__(self, other) -> bool: ...

@dataclass(frozen=True)
class Waypoint:
    prevControl: Union[Translation2d, None]
    anchor: Translation2d
    nextControl: Union[Translation2d, None]
    def flip(self) -> Waypoint:
        """
        Flip this waypoint to the other side of the field, maintaining a blue alliance origin

        :return: The flipped waypoint
        """
        ...

    @staticmethod
    def autoControlPoints(
        anchor: Translation2d,
        heading: Rotation2d,
        prevAnchor: Union[Translation2d, None],
        nextAnchor: Union[Translation2d, None],
    ) -> Waypoint:
        """
        Create a waypoint with auto calculated control points based on the positions of adjacent waypoints.
        This is used internally, and you probably shouldn't use this.

        :param anchor: The anchor point of the waypoint to create
        :param heading: The heading of this waypoint
        :param prevAnchor: The position of the previous anchor point. This can be None for the start point
        :param nextAnchor: The position of the next anchor point. This can be None for the end point
        :return: Waypoint with auto calculated control points
        """
        ...

    @staticmethod
    def fromJson(waypointJson: dict) -> Waypoint:
        """
        Create a waypoint from JSON

        :param waypointJson: JSON object representing a waypoint
        :return: The waypoint created from JSON
        """
        ...

class PathPlannerPath:
    _waypoints: List[Waypoint]
    _rotationTargets: List[RotationTarget]
    _pointTowardsZones: List[PointTowardsZone]
    _constraintZones: List[ConstraintsZone]
    _eventMarkers: List[EventMarker]
    _globalConstraints: PathConstraints
    _goalEndState: GoalEndState
    _idealStartingState: Union[IdealStartingState, None]
    _allPoints: List[PathPoint]
    _reversed: bool
    _isChoreoPath: bool = ...
    _idealTrajectory: Union[PathPlannerTrajectory, None] = ...
    _instances: int = ...
    _pathCache: dict[str, PathPlannerPath] = ...
    _choreoPathCache: dict[str, PathPlannerPath] = ...
    preventFlipping: bool = ...
    name: str = ...
    def __init__(
        self,
        waypoints: List[Waypoint],
        constraints: PathConstraints,
        ideal_starting_state: Union[IdealStartingState, None],
        goal_end_state: GoalEndState,
        holonomic_rotations: List[RotationTarget] = ...,
        point_towards_zones: List[PointTowardsZone] = ...,
        constraint_zones: List[ConstraintsZone] = ...,
        event_markers: List[EventMarker] = ...,
        is_reversed: bool = ...,
    ) -> None:
        """
        Create a new path planner path

        :param waypoints: List of waypoints representing the path. For on-the-fly paths, you likely want to use
            waypointsFromPoses to create these.
        :param constraints: The global constraints of the path
        :param ideal_starting_state: The ideal starting state of the path. Can be None if unknown
        :param goal_end_state: The goal end state of the path
        :param holonomic_rotations: List of rotation targets along the path
        :param constraint_zones: List of constraint zones along the path
        :param event_markers: List of event markers along the path
        :param is_reversed: Should the robot follow the path reversed (differential drive only)
        """
        ...

    @staticmethod
    def fromPathPoints(
        path_points: List[PathPoint],
        constraints: PathConstraints,
        goal_end_state: GoalEndState,
    ) -> PathPlannerPath:
        """
        Create a path with pre-generated points. This should already be a smooth path.

        :param path_points: Path points along the smooth curve of the path
        :param constraints: The global constraints of the path
        :param goal_end_state: The goal end state of the path
        :return: A PathPlannerPath following the given pathpoints
        """
        ...

    @staticmethod
    def fromPathFile(path_name: str) -> PathPlannerPath:
        """
        Load a path from a path file in storage

        :param path_name: The name of the path to load
        :return: PathPlannerPath created from the given file name
        """
        ...

    @staticmethod
    def fromChoreoTrajectory(
        trajectory_name: str, splitIndex: int = ...
    ) -> PathPlannerPath:
        """
        Load a Choreo trajectory as a PathPlannerPath

        :param trajectory_name: The name of the Choreo trajectory to load. This should be just the name of the trajectory. The trajectories must be located in the "deploy/choreo" directory.
        :param splitIndex: The index of the split to use
        :return: PathPlannerPath created from the given Choreo trajectory file
        """
        ...

    @staticmethod
    def clearPathCache() -> None:
        """
        Clear the cache of previously loaded paths.
        :return:
        """
        ...

    @staticmethod
    def waypointsFromPoses(poses: List[Pose2d]) -> List[Waypoint]:
        """
        Create the bezier waypoints necessary to create a path using a list of poses

        :param poses: List of poses. Each pose represents one waypoint.
        :return: Bézier curve waypoints
        """
        ...

    def getAllPathPoints(self) -> List[PathPoint]:
        """
        Get all the path points in this path

        :return: Path points in the path
        """
        ...

    def numPoints(self) -> int:
        """
        Get the number of points in this path

        :return: Number of points in the path
        """
        ...

    def getPoint(self, index: int) -> PathPoint:
        """
        Get a specific point along this path

        :param index: Index of the point to get
        :return: The point at the given index
        """
        ...

    def getGlobalConstraints(self) -> PathConstraints:
        """
        Get the global constraints for this path

        :return: Global constraints that apply to this path
        """
        ...

    def getGoalEndState(self) -> GoalEndState:
        """
        Get the goal end state of this path

        :return: The goal end state
        """
        ...

    def getIdealStartingState(self) -> Union[IdealStartingState, None]:
        """
        Get the ideal starting state of this path

        :return: The ideal starting state
        """
        ...

    def getEventMarkers(self) -> List[EventMarker]:
        """
        Get all the event markers for this path

        :return: The event markers for this path
        """
        ...

    def isReversed(self) -> bool:
        """
        Should the path be followed reversed (differential drive only)

        :return: True if reversed
        """
        ...

    def getStartingDifferentialPose(self) -> Pose2d:
        """
        Get the differential pose for the start point of this path

        :return: Pose at the path's starting point
        """
        ...

    def getStartingHolonomicPose(self) -> Union[Pose2d, None]:
        """
        Get the holonomic pose for the start point of this path. If the path does not have an ideal
        starting state, this will return None.

        :return: The ideal starting pose if an ideal starting state is present, None otherwise
        """
        ...

    def isChoreoPath(self) -> bool:
        """
        Check if this path is loaded from a Choreo trajectory

        :return: True if this path is from choreo, false otherwise
        """
        ...

    def generateTrajectory(
        self,
        starting_speeds: ChassisSpeeds,
        starting_rotation: Rotation2d,
        config: RobotConfig,
    ) -> PathPlannerTrajectory:
        """
        Generate a trajectory for this path.

        :param starting_speeds: The robot-relative starting speeds.
        :param starting_rotation: The starting rotation of the robot.
        :param config: The robot configuration
        :return: The generated trajectory.
        """
        ...

    def flipPath(self) -> PathPlannerPath:
        """
        Flip a path to the other side of the field, maintaining a global blue alliance origin
        :return: The flipped path
        """
        ...

    def mirrorPath(self) -> PathPlannerPath:
        """
        Mirror a path to the other side of the current alliance. For example, if this path is on the
        right of the blue alliance side of the field, it will be mirrored to the left of the blue
        alliance side of the field.
        :return: The mirrored path
        """
        ...

    def getPathPoses(self) -> List[Pose2d]:
        """
        Get a list of poses representing every point in this path.
        This can be used to display a path on a field 2d widget, for example.

        :return: List of poses for each point in this path
        """
        ...

    def getInitialHeading(self) -> Rotation2d:
        """
        Get the initial heading, or direction of travel, at the start of the path.

        :return: Initial heading
        """
        ...

    def getIdealTrajectory(
        self, robotConfig: RobotConfig
    ) -> Union[PathPlannerTrajectory, None]:
        """
        If possible, get the ideal trajectory for this path. This trajectory can be used if the robot
        is currently near the start of the path and at the ideal starting state. If there is no ideal
        starting state, there can be no ideal trajectory.

        :param robotConfig: The config to generate the ideal trajectory with if it has not already been generated
        :return: The ideal trajectory if it exists, None otherwise
        """
        ...

    def getWaypoints(self) -> List[Waypoint]:
        """
        Get the waypoints for this path

        :return: List of this path's waypoints
        """
        ...

    def getRotationTargets(self) -> List[RotationTarget]:
        """
        Get the rotation targets for this path

        :return: List of this path's rotation targets
        """
        ...

    def getPointTowardsZones(self) -> List[PointTowardsZone]:
        """
        Get the point towards zones for this path

        :return: List of this path's point towards zones
        """
        ...

    def getConstraintZones(self) -> List[ConstraintsZone]:
        """
        Get the constraint zones for this path

        :return: List of this path's constraint zones
        """
        ...

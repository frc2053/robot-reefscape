"""
This type stub file was generated by pyright.
"""

from .controller import PathFollowingController
from .path import GoalEndState, PathConstraints, PathPlannerPath
from .trajectory import PathPlannerTrajectory
from .util import DriveFeedforwards
from wpimath.geometry import Pose2d
from wpimath.kinematics import ChassisSpeeds
from wpilib import Timer
from commands2 import Command, SequentialCommandGroup, Subsystem
from typing import Callable, Union
from .config import RobotConfig
from .events import EventScheduler

class FollowPathCommand(Command):
    _originalPath: PathPlannerPath
    _poseSupplier: Callable[[], Pose2d]
    _speedsSupplier: Callable[[], ChassisSpeeds]
    _output: Callable[[ChassisSpeeds, DriveFeedforwards], None]
    _controller: PathFollowingController
    _robotConfig: RobotConfig
    _shouldFlipPath: Callable[[], bool]
    _eventScheduler: EventScheduler
    _timer: Timer = ...
    _path: PathPlannerPath = ...
    _trajectory: PathPlannerTrajectory = ...
    currentPathName: str = ...
    def __init__(
        self,
        path: PathPlannerPath,
        pose_supplier: Callable[[], Pose2d],
        speeds_supplier: Callable[[], ChassisSpeeds],
        output: Callable[[ChassisSpeeds, DriveFeedforwards], None],
        controller: PathFollowingController,
        robot_config: RobotConfig,
        should_flip_path: Callable[[], bool],
        *requirements: Subsystem,
    ) -> None:
        """
        Construct a base path following command

        :param path: The path to follow
        :param pose_supplier: Function that supplies the current field-relative pose of the robot
        :param speeds_supplier: Function that supplies the current robot-relative chassis speeds
        :param output: Output function that accepts robot-relative ChassisSpeeds and feedforwards for
            each drive motor. If using swerve, these feedforwards will be in FL, FR, BL, BR order. If
            using a differential drive, they will be in L, R order.
            <p>NOTE: These feedforwards are assuming unoptimized module states. When you optimize your
            module states, you will need to reverse the feedforwards for modules that have been flipped
        :param controller: Path following controller that will be used to follow the path
        :param robot_config The robot configuration
        :param should_flip_path: Should the path be flipped to the other side of the field? This will maintain a global blue alliance origin.
        :param requirements: Subsystems required by this command, usually just the drive subsystem
        """
        ...

    def initialize(self) -> None: ...
    def execute(self) -> None: ...
    def isFinished(self) -> bool: ...
    def end(self, interrupted: bool) -> None: ...

class PathfindingCommand(Command):
    _timer: Timer = ...
    _targetPath: Union[PathPlannerPath, None]
    _targetPose: Pose2d
    _originalTargetPose: Pose2d
    _goalEndState: GoalEndState
    _constraints: PathConstraints
    _poseSupplier: Callable[[], Pose2d]
    _speedsSupplier: Callable[[], ChassisSpeeds]
    _output: Callable[[ChassisSpeeds, DriveFeedforwards], None]
    _controller: PathFollowingController
    _robotConfig: RobotConfig
    _shouldFlipPath: Callable[[], bool]
    _currentPath: Union[PathPlannerPath, None]
    _currentTrajectory: Union[PathPlannerTrajectory, None]
    _timeOffset: float = ...
    _finish: bool = ...
    _instances: int = ...
    def __init__(
        self,
        constraints: PathConstraints,
        pose_supplier: Callable[[], Pose2d],
        speeds_supplier: Callable[[], ChassisSpeeds],
        output: Callable[[ChassisSpeeds, DriveFeedforwards], None],
        controller: PathFollowingController,
        robot_config: RobotConfig,
        should_flip_path: Callable[[], bool],
        *requirements: Subsystem,
        target_path: PathPlannerPath = ...,
        target_pose: Pose2d = ...,
        goal_end_vel: float = ...,
    ) -> None:
        """
        Construct a pathfinding command

        :param constraints: The constraints to use while path following
        :param pose_supplier: Function that supplies the current field-relative pose of the robot
        :param speeds_supplier: Function that supplies the current robot-relative chassis speeds
        :param output: Output function that accepts robot-relative ChassisSpeeds and feedforwards for
            each drive motor. If using swerve, these feedforwards will be in FL, FR, BL, BR order. If
            using a differential drive, they will be in L, R order.
            <p>NOTE: These feedforwards are assuming unoptimized module states. When you optimize your
            module states, you will need to reverse the feedforwards for modules that have been flipped
        :param controller: Path following controller that will be used to follow the path
        :param robot_config The robot configuration
        :param should_flip_path: Should the path be flipped to the other side of the field? This will maintain a global blue alliance origin.
        :param requirements: Subsystems required by this command, usually just the drive subsystem
        :param target_path: The path to pathfind to. This should be None if target_pose is specified
        :param target_pose: The pose to pathfind to. This should be None if target_path is specified
        :param goal_end_vel: The goal end velocity when reaching the target path/pose
        """
        ...

    def initialize(self) -> None: ...
    def execute(self) -> None: ...
    def isFinished(self) -> bool: ...
    def end(self, interrupted: bool) -> None: ...

class PathfindThenFollowPath(SequentialCommandGroup):
    def __init__(
        self,
        goal_path: PathPlannerPath,
        pathfinding_constraints: PathConstraints,
        pose_supplier: Callable[[], Pose2d],
        speeds_supplier: Callable[[], ChassisSpeeds],
        output: Callable[[ChassisSpeeds, DriveFeedforwards], None],
        controller: PathFollowingController,
        robot_config: RobotConfig,
        should_flip_path: Callable[[], bool],
        *requirements: Subsystem,
    ) -> None:
        """
        Constructs a new PathfindThenFollowPath command group.

        :param goal_path: the goal path to follow
        :param pathfinding_constraints: the path constraints for pathfinding
        :param pose_supplier: a supplier for the robot's current pose
        :param speeds_supplier: a supplier for the robot's current robot relative speeds
        :param output: Output function that accepts robot-relative ChassisSpeeds and feedforwards for
            each drive motor. If using swerve, these feedforwards will be in FL, FR, BL, BR order. If
            using a differential drive, they will be in L, R order.
            <p>NOTE: These feedforwards are assuming unoptimized module states. When you optimize your
            module states, you will need to reverse the feedforwards for modules that have been flipped
        :param controller Path following controller that will be used to follow the path
        :param robot_config The robot configuration
        :param should_flip_path: Should the path be flipped to the other side of the field? This will maintain a global blue alliance origin.
        :param requirements: the subsystems required by this command (drive subsystem)
        """
        ...

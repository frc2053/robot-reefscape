"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from wpimath.geometry import Pose2d, Rotation2d, Translation2d
from wpimath.kinematics import ChassisSpeeds
from enum import Enum
from typing import List

def translation2dFromJson(translationJson: dict) -> Translation2d: ...

class FieldSymmetry(Enum):
    kRotational = ...
    kMirrored = ...

@dataclass(frozen=True)
class DriveFeedforwards:
    accelerationsMPS: List[float] = ...
    forcesNewtons: List[float] = ...
    torqueCurrentsAmps: List[float] = ...
    robotRelativeForcesXNewtons: List[float] = ...
    robotRelativeForcesYNewtons: List[float] = ...
    @staticmethod
    def zeros(numModules: int) -> DriveFeedforwards:
        """
        Create drive feedforwards consisting of all zeros

        :param numModules: Number of drive modules
        :return: Zero feedforwards
        """
        ...

    def interpolate(self, endVal: DriveFeedforwards, t: float) -> DriveFeedforwards: ...
    def reverse(self) -> DriveFeedforwards:
        """
        Reverse the feedforwards for driving backwards. This should only be used for differential drive robots.

        :return: Reversed feedforwards
        """
        ...

    def flip(self) -> DriveFeedforwards:
        """
        Flip the feedforwards for the other side of the field. Only does anything if mirrored symmetry is used

        :return: Flipped feedforwards
        """
        ...

class FlippingUtil:
    symmetryType: FieldSymmetry = ...
    fieldSizeX: float = ...
    fieldSizeY: float = ...
    @staticmethod
    def flipFieldPosition(pos: Translation2d) -> Translation2d:
        """
        Flip a field position to the other side of the field, maintaining a blue alliance origin

        :param pos: The position to flip
        :return: The flipped position
        """
        ...

    @staticmethod
    def flipFieldRotation(rotation: Rotation2d) -> Rotation2d:
        """
        Flip a field rotation to the other side of the field, maintaining a blue alliance origin

        :param rotation: The rotation to flip
        :return: The flipped rotation
        """
        ...

    @staticmethod
    def flipFieldPose(pose: Pose2d) -> Pose2d:
        """
        Flip a field pose to the other side of the field, maintaining a blue alliance origin

        :param pose: The pose to flip
        :return: The flipped pose
        """
        ...

    @staticmethod
    def flipFieldSpeeds(fieldSpeeds: ChassisSpeeds) -> ChassisSpeeds:
        """
        Flip field relative chassis speeds for the other side of the field, maintaining a blue alliance origin

        :param fieldSpeeds: Field relative chassis speeds
        :return: Flipped speeds
        """
        ...

    @staticmethod
    def flipFeedforwards(feedforwards: List[float]) -> List[float]:
        """
        Flip a list of drive feedforwards for the other side of the field.
        Only does anything if mirrored symmetry is used

        :param feedforwards: List of drive feedforwards
        :return: The flipped feedforwards
        """
        ...

    @staticmethod
    def flipFeedforwardXs(feedforwardXs: List[float]) -> List[float]:
        """
        Flip a list of drive feedforward X components for the other side of
        the field. Only does anything if mirrored symmetry is used

        :param feedforwardXs: List of drive feedforward X components
        :return: The flipped feedforward X components
        """
        ...

    @staticmethod
    def flipFeedforwardYs(feedforwardYs: List[float]) -> List[float]:
        """
        Flip a list of drive feedforward Y components for the other side of
        the field. Only does anything if mirrored symmetry is used

        :param feedforwardYs: List of drive feedforward Y components
        :return: The flipped feedforward Y components
        """
        ...

def floatLerp(start_val: float, end_val: float, t: float) -> float:
    """
    Interpolate between two floats

    :param start_val: Start value
    :param end_val: End value
    :param t: Interpolation factor (0.0-1.0)
    :return: Interpolated value
    """
    ...

def translationLerp(a: Translation2d, b: Translation2d, t: float) -> Translation2d:
    """
    Linear interpolation between two Translation2ds

    :param a: Start value
    :param b: End value
    :param t: Interpolation factor (0.0-1.0)
    :return: Interpolated value
    """
    ...

def rotationLerp(a: Rotation2d, b: Rotation2d, t: float) -> Rotation2d:
    """
    Interpolate between two Rotation2ds

    :param a: Start value
    :param b: End value
    :param t: Interpolation factor (0.0-1.0)
    :return: Interpolated value
    """
    ...

def poseLerp(a: Pose2d, b: Pose2d, t: float) -> Pose2d:
    """
    Interpolate between two Pose2ds

    :param a: Start value
    :param b: End value
    :param t: Interpolation factor (0.0-1.0)
    :return: Interpolated value
    """
    ...

def quadraticLerp(
    a: Translation2d, b: Translation2d, c: Translation2d, t: float
) -> Translation2d:
    """
    Quadratic interpolation between Translation2ds

    :param a: Position 1
    :param b: Position 2
    :param c: Position 3
    :param t: Interpolation factor (0.0-1.0)
    :return: Interpolated value
    """
    ...

def cubicLerp(
    a: Translation2d, b: Translation2d, c: Translation2d, d: Translation2d, t: float
) -> Translation2d:
    """
    Cubic interpolation between Translation2ds

    :param a: Position 1
    :param b: Position 2
    :param c: Position 3
    :param d: Position 4
    :param t: Interpolation factor (0.0-1.0)
    :return: Interpolated value
    """
    ...

def calculateRadius(a: Translation2d, b: Translation2d, c: Translation2d) -> float:
    """
    Calculate the curve radius given 3 points on the curve

    :param a: Point A
    :param b: Point B
    :param c: Point C
    :return: Curve radius
    """
    ...

def decimal_range(
    start: float, stop: float, increment: float
):  # -> Generator[float, Any, None]:
    ...
